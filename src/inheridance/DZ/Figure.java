package inheridance.DZ;

public abstract class Figure {  //сделали сам класс абстрактный потому что появился метод абстрактный и плюс защитились
                                //от создания объекта просто какой-то непонятной фигуры.
    private double a;
    private double b;


    public Figure(double a, double b) {
        this.a = a;
        this.b = b;
    }


    public double getA() {
        return a;
    }
    public final double getB() {
        return b;
    }


    //Метод area() ничего не делает, и если мы забудем его переопределить он нам вернет 0 (по его старой реализации),
    //нас это не устраивает!
    //Если у метода нет своей реализации и он обязательно должен быть переопределен то мы пишем ключевое слово abstract
    //и удаляем бесполезную реализацию (return 0)! Если в классе есть хотябы один абстрактный метод, то и класс должен
    //быть абстрактный. А если класс абстрактный, то ме не можем создать экз. этого класса.
    public abstract double area();
}
